open FStar_Range
open FStar_Tactics_Types
open FStar_Tactics_Result
open FStar_Tactics_Basic
open FStar_Syntax_Syntax

module BU = FStar_Util

(* These definitions are â‰¡ to the ones generated by F*'s extraction of the
   tactic effect.  We need them here to break a circular dependency between the
   compiler and ulib (cf. tactics meeting of 2017-08-03). *)
type 'a __tac = FStar_Tactics_Types.proofstate -> 'a __result
type 'a tactic = Prims.unit -> 'a __tac

let r = dummyRange

type itac = FStar_TypeChecker_Normalize.psc -> args -> term option
type native_primitive_step =
    { name: FStar_Ident.lid;
      arity: Prims.int;
      strong_reduction_ok: bool;
      tactic: itac}

let compiled_tactics: native_primitive_step list ref = ref []

let list_all () = !compiled_tactics

let is_native_tactic lid =
    BU.is_some (BU.try_find (fun x -> FStar_Ident.lid_equals lid x.name) !compiled_tactics)

let register_tactic (s: string) (arity: int) (t: itac)=
    let step =
        { name=FStar_Ident.lid_of_str s;
          arity = Z.of_int arity;
          strong_reduction_ok=false;
          tactic=t } in
    compiled_tactics := step :: !compiled_tactics;
    BU.print1 "Registered tactic %s\n" s

let interpret_tactic (ps: proofstate) (t: proofstate -> 'a __result) = t ps

let from_tactic_0 (t: 'b tactic): ('b tac) =
    (fun (ps: proofstate) ->
        BU.print_string "In compiled code\n";
        let m = t () in
        interpret_tactic ps m) |> mk_tac

let from_tactic_1 (t: 'a -> 'b tactic): ('a -> 'b tac) =
    fun (x: 'a) ->
        (fun (ps: proofstate) ->
            BU.print_string "In compiled code\n";
            let m = t x in
            let (m2: proofstate -> 'b __result) = m () in
            interpret_tactic ps m2) |> mk_tac

let from_tactic_2 (t: 'a -> 'b -> 'c tactic): ('a -> 'b -> 'c tac) =
    fun (x: 'a) ->
        fun (y: 'b) ->
            (fun (ps: proofstate) ->
                BU.print_string "In compiled code\n";
                let m = t x y in
                let (m2: proofstate -> 'c __result) = m () in
                interpret_tactic ps m2) |> mk_tac
